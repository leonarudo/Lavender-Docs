{
  "docs/CommandLib/CommandManager.html": {
    "href": "docs/CommandLib/CommandManager.html",
    "title": "CommandManager Static Class | Lavender Docs",
    "summary": "CommandManager Static Class Definition Namespace: Lavender.CommandLib Source: CommandManager.cs Remarks The CommandManager gives you the ability to add custom commands to the developer console using IConsoleCommand as command handler. Methods RegisterCommand(IConsoleCommand) Register an IConsoleCommand with the handler PrintToDevConsole(object) Prints a message to the dev console"
  },
  "docs/CommandLib/IConsoleCommand.html": {
    "href": "docs/CommandLib/IConsoleCommand.html",
    "title": "IConsoleCommand Interface | Lavender Docs",
    "summary": "IConsoleCommand Interface Definition Namespace: Lavender.CommandLib Source: IConsoleCommand.cs Examples Creating a custom command: using Lavender.CommandLib; public class EchoCommand : IConsoleCommand { public string Name => \"echo\"; public string Description => \"echoes whatever you tell it to\"; public string Usage => \"echo <string>\"; public void Execute(params string[] args) { if (args.Length < 2) { CommandManager.PrintToDevConsole(Usage); return; } //Specifically call string.Trim(char[]) instead of //string.Trim(char) to avoid a netstandard 2.0 -> 2.1 //issue CommandManager.PrintToDevConsole(args[1].Trim(['\"'])); } } Register the command: CommandManager.RegisterCommand(new EchoCommand()); Put this in ur plugin innit code; e.g., In your BaseUnityPlugin class in Awake() Properties Name The name of the console command, (e.g., \"give\"). Description The description of the console command (e.g., \"Gives the player an item\"). Usage A short explanation on how to use the console command (e.g., \"give [item_name]\"). Methods Execute(params string[]) A function to be executed when the console command is run."
  },
  "docs/DialogueLib/ConversationPatcher.html": {
    "href": "docs/DialogueLib/ConversationPatcher.html",
    "title": "ConversationPatcher class | Lavender Docs",
    "summary": "ConversationPatcher class Definition Namespace: Lavender.DialogueLib Source: ConversationPatcher.cs Usage The base class for any dialogue patching. Make a child class in your mod and implement the PatchDialogue() function. Ensure that your child class's constructor correctly passes the name of the conversation to patch to the base constructor (see below). In your mod's Start, create and register an instance of the child class with Lavender.AddConversationPatcher(). It is safe to keep a reference to the patcher object in your mod. Once passed to Lavender, you no longer have to manage the object's lifespan, and can assume it will remain valid for the duration of the play session. The name of the conversation to patch MUST be passed to ConversationPatcher's constructor from your child class's constructor: public class TatyanaConversation : ConversationPatcher { public TatyanaConversation() : base(\"Tenement/Outside/Tatyana Gopnikova\") { } } Usage Examples Examples of the ConversationPatcher in action can be see in the Lavender Test project: TestConversationPatcherTatyana.cs TestConversationPatcherTatyana2.cs Note that both of these files patch the same conversation at the same time. They avoid conflict by not relying on hard node IDs, and instead using Lavender's utility functions to find which nodes to best respond to Static Properties Pause A convenience definition to insert a \"pause\" command into a dialogue line: $\"Wait for it.{Pause}.{Pause}.{Pause}. BOOM!\" Quote A convenience definition to insert a quotation mark into a dialogue line: $\"He said {Quote}She said{Quote}\" Lua(\"Lua script\") Note: Actually a method, but it belongs with Pause and Quote. Convenience definition to insert a parsable Lua script into dialogue text: $\"You owe me {Lua(\"GetOwedMoney()\")} coins.\" Properties Conversation The Conversation object in the PixelCrushers DialogueSystem. Note that this reference is ONLY guaranteed valid while executing PatchDialogue or OnConversationStarted ConversationName String name of the conversation this patcher modifies. Immutable. Virtual Methods (for implementation in child classes) PatchDialogue() Implement in your child class and perform all logic you need to patch the dialogue. This is the ONLY time that it is safe to patch dialogue. OnConversationStarted(InteractableTalk) Called just before the fullscreen dialogue UI opens. If you want to register Lua functions that are ONLY available while this conversation is active, then do so within this function OnConversationEnded(InteractableTalk) Called when the fullscreen dialogue UI has closed. If you have conversation-specific Lua functions, make sure to unregister them here WARNING! This can be called multiple times (up to 4 times for each OnConversationStarted call). Methods PlayerSays(string) Create a new DialogueEntry spoken *by* the player belonging to this conversation. It still needs to be Link(). WARNING! Only valid to call inside of PatchDialogue() NPCSays(string) Create a new DialogueEntry spoken *by* the NPC. It still needs to be Link(). WARNING! Only valid to call inside of PatchDialogue() Link(DialogueEntry source, DialogueEntry destination, LinkOrdering? ordering = null, ConditionPriority priority = ConditionPriority.Normal) Create a dialogue navigation link from source to destination, allowing dialogue to flow (either automatically by NPC speaking or by player selecting a response). See LinkOrdering to control where player responses appear in the UI GetResponsesTo(DialogueEntry) Return an IEnumerable of entries belonging to this conversation that are valid NPC and/or player responses to the provided entry. GetStaticResponsesTo(DialogueEntry) Return an IEnumerable of entries belonging to this conversation that are valid NPC and/or player responses to the provided entry. Excludes any responses with Lua criteria, formatting, or callbacks. AdvanceToRespondable(DialogueEntry) Return an IEnumerable of the soonest entries in the dialogue tree where the player can insert a response choice. This may be the same entry as passed in, or it may be multiple entries at the same depth."
  },
  "docs/FurnitureLib/FurnitureConfig.html": {
    "href": "docs/FurnitureLib/FurnitureConfig.html",
    "title": "FurnitureConfig Class | Lavender Docs",
    "summary": "FurnitureConfig Class Definition Namespace: Lavender.FurnitureLib Source: FurnitureConfig.cs Example Warning Lavender supports loading images and obj's at runtime, but the obj importer is currently pretty buggy. For the best and more stable results use AssetBundle imports instead! Note imageName, prefabName and previewPrefabName only accept LavenderAssets! FurnitureConfig.json { \"id\": 0, \"title\": \"Name\", \"details\":\"Description\", \"priceOC\": 0, \"priceRM\": 0, \"trash\": false, \"imageName\":\"#lv_modname-001\", \"prefabName\":\"#lv_modname-101\", \"previewPrefabName\":\"#lv_modname-101\", \"category\": \"ALL\", \"restrictedAreas\": [ ], \"displayStyle\": \"Default\", \"placeType\": \"all\", \"displayRotationY\": 0 } Properties id Furniture ID title The name of the furniture details A short description of the furniture priceOC OC price priceRM RM price trash ? imageName LavenderAsset-ID 'ModName-id' e.g. Lavender-100 prefabName LavenderAsset-ID 'ModName-id' e.g. Lavender-100 previewPrefabName LavenderAsset-ID 'ModName-id' e.g. Lavender-100 category The category of the Furniture restrictedAreas Restricted areas to build the furniture -> Allowed to put everywhere if empty displayStyle Should it be positioned like a normal furniture or like a painting or ceiling object? placeType Restricted places to build (wall, floor, etc) displayRotationY Display rotation on the Y-Aches Furniture Config Enums FurnitureCategory All Chairs Tables Electronics Paintings Lights Rugs Items Machines Storage Clutter Beds Sofas Decoration Plants Shelves Manufacturing Growing Letters Bathroom Signs Magazines Posters Curtains Flags LicensePlates Kitchen Tank None FurnitureDisplayStyle Default Painting Ceiling FurnitureBuildingArea None Stairs PlayerApartment Workshop Outside Greenhouse Store Communal Public FurniturePlaceType all floor wall ceiling floorAndWall"
  },
  "docs/FurnitureLib/FurnitureCreator.html": {
    "href": "docs/FurnitureLib/FurnitureCreator.html",
    "title": "FurnitureCreator \"Static\" Class | Lavender Docs",
    "summary": "FurnitureCreator \"Static\" Class Definition Namespace: Lavender.FurnitureLib Source: FurnitureCreator.cs Remarks The FurnitureCreator allows you to create furniture's either from an FurnitureConfig json or directly by setting the right parameters in FurnitureCreator.NewFurniture(...) (if you know what your doing xD) If you just want to create some furniture's stick to Create(...) and CreateShopFurniture(...). Methods NewFurniture(string, string, Sprite, string, Furniture.Category, int, int, GameObject, GameObject, Furniture.BuildingArea[], List , FurniturePlaceType, Furniture.DisplayStyle, int, bool) Creates an Furniture object and setups the prefab entity structure. *This function is for those who know what there doing!* FurnitureConfigToFurniture(FurnitureConfig) Uses a FurnitureConfig to create a Furniture Create(string, bool = false) Creates a Furniture from the given path to the FurnitureConfig json and adds it to the FurnitureDatabase CreateShopFurniture(string, int) Creates an BuildingSystem.FurnitureInfo for the FurnitureShopRestockHandler CreateShopFurniture(int, string) Creates an BuildingSystem.FurnitureInfo for the FurnitureShopRestockHandler"
  },
  "docs/FurnitureLib/HandlerAttributes.html": {
    "href": "docs/FurnitureLib/HandlerAttributes.html",
    "title": "HandlerAttributes (FurnitureLib) | Lavender Docs",
    "summary": "HandlerAttributes (FurnitureLib) Namespace: Lavender.FurnitureLib Source: HandlerAttributes.cs FurniturePrefabHandlerAttribute The Furniture Prefab Handler Attribute allows you to add custom scripts to your furniture prefab or to in-game furniture prefabs! The Handler will always be called every time your or an in-game furniture gets newly loaded for the FurnitureDatabase. (at the beginning of every scene containing your furniture) Scripts added to your prefabs directly in the AssetBundle are likely causing errors, so always add your scripts using this handler! Example using Lavender.FurnitureLib; // This Handler function gets called every time your furniture gets loaded! [FurniturePrefabHandler(\"YourFurnitureTitle\")] public static GameObject YourFurniturePrefabHandler(GameObject gameobject) { // ... -> do something with the furniture prefab, like prefab.AddComponent<T>() return gameobject; } /* Alternatively you can add custom scripts or edit in-game furniture * by setting the bool isIngameFurniture = true and parsing * the in-game furniture name to the handler attribute! */ [FurniturePrefabHandler(\"Laptop\", true)] public static GameObject LaptopPrefabPatch(GameObject prefab) { // ... -> do something with the Laptop Furniture prefab! return prefab; } In order to make the FurniturePrefabHandler work, you need to register it: using Lavender; // Put this in your mod Awake() function Lavender.AddFurniturePrefabHandlers(typeof(the_class_containing_the_FurnitureHandler)); Constructors FurniturePrefabHandler(string, bool) Initializes a new instance of the FurniturePrefabHandlerAttribute class Properties FurnitureTitle The furniture title defines the furniture the handler is applied to! isIngameFurniture Is this furniture an in-game one? Default = false FurnitureShopRestockHandlerAttribute The Furniture Shop Restock Handler Attribute allows you to add your furniture every time a restock event occurs! Example using Lavender.FurnitureLib; [FurnitureShopRestockHandlerAttribute(\"AnyID\")] public static List<BuildingSystem.FurnitureInfo> FurShopRestockHandler(FurnitureShopName name) { List<BuildingSystem.FurnitureInfo> restock = new List<BuildingSystem.FurnitureInfo>(); string path = \"FurnitureConfig.json\"; // Idea: Randomize the restock amount to make it more realistic int amount = 20; BuildingSystem.FurnitureInfo? info = FurnitureCreator.CreateShopFurniture(path, amount); if(info != null) restock.Add(info); return restock; } In order to make the FurnitureShopRestockHandler work, you need to register it: using Lavender; // Put this in your mod Awake() function Lavender.AddFurnitureShopRestockHandlers(typeof(the_class_containing_the_FurnitureShopRestockHandler)); Constructors FurnitureShopRestockHandler(string) Initializes a new instance of the FurnitureShopRestockHandlerAttribute class. Properties HandlerUID A Unique ID needed incase you want to remove an handler after registering it. FurnitureShopName Enum The FurnitureShopName Enum which is one of the parameters of the FurnitureShopRestockHandler function allows you to identify which furniture shop the restock event came from. Values None If none of the other values fit, the enum will be set to ``FurnitureShopName.None`` OneStopShop One Stop Shop MoebelmannFurnitures MÃ¶belmann Furnitures SamuelJonasson Jonasson's Shop OSMiningServices OS Mining Services"
  },
  "docs/Guides/Your-First-Mod.html": {
    "href": "docs/Guides/Your-First-Mod.html",
    "title": "Your First Mod | Lavender Docs",
    "summary": "Your First Mod You will learn: How to use the Unity Explorer Object Browser How to use the Unity Explorer Inspector Window to inspect an object How to use the Unity Explorer Hooks menu to design a hook How to recreate that hook in a plugin loaded by BepInEx This guide was originaly wirtten by Robyn Install Prerequisites Note This guide assumes you've already installed BepInEx following the instructions from their repository. You specifically want the latest version 5 LTS Plugin Template for Obenseuer Note If you've already done this step then go ahead and skip to the next one, great job! You can find the template and install instructions here Unity Explorer for BepinEx 5 You can get the most maintained branch of Unity Explorer from Yukieiji as the original author, Sinai-Dev archived the original project several years ago. Tip Unity Explorer is possibly the most important tool in a Unity game modder's arsenal. Before continuing from this step, I suggest you simply click around in-game and explore the hierarchy browser, object inspector, free cam and C# REPL Console features of UE. Setup Your First Plugin Instance the Template Following the instructions from the Template repo, create a new folder where your project will live and make sure it has a nice name, this will be the name of your plugin. From inside this folder run dotnet new OSBepinPlugin and your plugin will be initialized to a base state. Setup the Config File Tip If you've used the template before you can safely copy your Config.build.user.props file from one folder to the other. It will generally be the same between projects. If this is your first time using the template copy the Config.Build.user.props.template file and rename the copy to remove everything after the .props part. It should look like Config.Build.user.props exactly, proper case matters here! This file is simply an xml document with a goofy name so you can open it with any text editor, but I'd suggest your IDE of choice, for example, visual studio, VSCode or Rider. There will be a line defining the GameDir property with the text full/path/to/game, replace this with the actual full path to your game. You can find this by right-clicking your game in steam and selecting manage -> browse local files. This is required for automatically finding the game's DLL files to depend on when modding so you can't skip this step Now go ahead and do a test build of your project. If you are using VSCode the default action will be a build and deploy action so you will see console output that contains Deploy -> somewhere near the bottom. If you are using VS I have included a task that should do the same but if it doesn't you simply use dotnet build -p:DeployToProd=true to get the same build and deploy features. Note If you do not see the console output for Deploy -> in your build step, check the plugin directory for your game anyway and see if its working silently. Newer versions of MSBuild seem to consume the output of tasks without displaying it to the user so it may be running silently. The plugin is now set up and your game has Unity Explorer. Let's find something to patch! Using Unity Explorer to Design a Mod For this example we'll just stick to something simple. Why don't we react to when the player breaks a lockpick? Why? Because its really simple to do and demonstrates the process, hehe. Tip Consider doing all your experimentation on a clean save with a fresh startup of the game. Any tinkering you did before might still exist in the hierarchy (if you chose to spend some time with UE, like I suggested earlier). For testing, I have a save with a specific name so I don't forget its just for testing and cheating. Finding Our Hook Entrypoint Since we want to interact with the player, let's open the Object Explorer and search the scene for \"Player\", I already know which object it is but try to figure out what GameObject in the hierarchy is the actual player object and not a map marker or UI panel container. If you found it, great job! If you gave up, its the object called \"[2] Player\" this indicates it has 2 child objects, in this case Player Camera Base and ECM Player. Select the Player object and in its Inspector Window select the ECM Player object because it contains most of the physical presence of the player like various movement controllers and other components. Tip Hey, what's that DeveloperMovement component? What happens if you open it in the inspector and scroll down to the method ActivateDebugMovement() When you're done fooling around DeactivateDebugMovement() and continue to the next step. The ECM Player object contains a child object named Player (yes we're going in circles, here) and that has a component named CharacterScripts. This component has a whole lot of goodies to play with but we're interested in the component PlayerLockpicking which handles all the of the lockpicking interactions. Open this component in the inspector and see if you can figure out what method we're about to target. If you're having trouble finding just methods use the tick-boxes at the top of the inspector to toggle off properties and fields. Notice the method named BreakLockpick. Let's check when it fires by making a hook in the game without needing to load a plugin. At the top of the screen click the Hooks button to open the Hooks menu. Use the field labelled Enter a class to add hooks to to filter to \"PlayerLockpicking\" and then click \"view methods\". Filter to BreakLockpick and click the Hook button to generate a default postfix (runs after) hook for the method. Feel free to click the edit button on your new hook but don't change anything yet. Right now the default hook is just a log output every time the method is fired, which suits us just fine. Find something you can lockpick and break your pick. You should be able to see the log output if you click the button labelled Log on the UE top bar menu. Normally we'd want to do more than log, but for the purpose of an example we're satisfied with this hook. So now let's recreate it, but in a plugin! Note Hooks do not survive closing the game and must be manually re-entered each time you do so. If you are working on code in a hook, keep a code editor open outside the game to hold a copy so you don't lose it in the event you crash the game (you will) Recreating the Hook in a Plugin For this example, I've created a plugin named LockPickingLoser and added the hook we made above as a patch using Harmony. The template has extensive documentation on how to use Harmony for basic patches and why and how certain things are done the way they are. Please read through it and try to create the patch yourself. If you get stuck or lost, I'll include the full text of both the Patch and the Plugin class to help or just to compare to. Plugin.cs using BepInEx; using BepInEx.Logging; using HarmonyLib; using LockpickingLoser.Patches; namespace LockpickingLoser; [BepInPlugin(LCMPluginInfo.PLUGIN_GUID, LCMPluginInfo.PLUGIN_NAME, LCMPluginInfo.PLUGIN_VERSION)] public class Plugin : BaseUnityPlugin { internal static ManualLogSource Log = null!; private void Awake() { /* BepinEx makes you a ManualLogSource for free called \"Logger\" and I created a static value above to hold on to it so other parts of your plugin's code can find it by using Plugin.Log We assign it here */ Log = Logger; // Log our awake here so we can see it in LogOutput.txt file Log.LogInfo($\"Plugin {LCMPluginInfo.PLUGIN_NAME} version {LCMPluginInfo.PLUGIN_VERSION} is loaded!\"); Harmony myHarmony = new(LCMPluginInfo.PLUGIN_GUID); myHarmony.PatchAll(typeof(PlayerLockpickingPatches)); } } PlayerLockpicking.cs using System.Text; using HarmonyLib; namespace LockpickingLoser.Patches; public class PlayerLockpickingPatches { [HarmonyPatch(typeof(PlayerLockpicking), nameof(PlayerLockpicking.BreakLockpick))] [HarmonyPostfix] public static void PlayerLockpicking_BreakLockpick_Postfix(PlayerLockpicking __instance) { try { StringBuilder sb = new StringBuilder(); sb.AppendLine(\"--------------------\"); sb.AppendLine(\"void PlayerLockpicking::BreakLockpick()\"); sb.Append(\"- __instance: \").AppendLine(__instance.ToString()); Plugin.Log.LogMessage(sb.ToString()); } catch (System.Exception ex) { Plugin.Log.LogWarning($\"Exception in patch of void PlayerLockpicking::BreakLockpick():\\n{ex}\"); } } } You should see the following in your LogOutput.log file: [Message:LockpickingLoser] -------------------- void PlayerLockpicking::BreakLockpick() - __instance: CharacterScripts (PlayerLockpicking) That's it for the basic overview of making a hook and creating a patch. For more advanced information follow the links to the Harmony docs regarding injectors in the template's patch example."
  },
  "docs/Guides/getting-started.html": {
    "href": "docs/Guides/getting-started.html",
    "title": "Getting Started | Lavender Docs",
    "summary": "Getting Started"
  },
  "docs/Item-n-Recipe/Items.html": {
    "href": "docs/Item-n-Recipe/Items.html",
    "title": "Items | Lavender Docs",
    "summary": "Items Note Item and Recipes are identified via integer values. This, unfortunately, means that conflicts between mods are possible if we (as a community) do not communicate and document which mod(ders) use which ID regions. See current ID Allocations here Item.json Lavender allows you to add new Items to Obenseuer without editing the native Items.json file! Since Lavenders Item.json format is exactly the same as Obenseuers one (it even uses Obenseuers Code to read it) you can simply learn from Obenseuers Item.json file how to add Items! Example [ { \"ID\": 101, \"Title\": \"Item Name\", \"Categories\": [ \"CategoryName\" ], \"Value\": 1, \"Description\": \"Modded Item\", \"Stackable\": 99, \"Appearance\": { \"Material\": \"\", \"SpritePath\": \"#lv_ExampleItemMod-001\", \"ColorValue\": \"\", \"PrefabPath\": \"#lv_ExampleItemMod-101\", \"PrefabPathMany\": \"\" }, \"Actions\": [], \"Attachments\": { \"Name\": \"\", \"Attachment1\": \"none\", \"Attachment2\": \"none\" }, \"Meta\": [] } ] In order to add Items through your own Item.json you need to register it to Lavender. string itemsPath = \"Items.json\"; Lavender.AddCustomItemsFromJson(itemsPath, LCMPluginInfo.PLUGIN_NAME); Keys Note When explained as '???' then I'm either unsure what it is or how to explain it. Take a look at Obenseuer's Item.json for more infos on those Keys. ID Unique ID for the Item, which is used in the Item Database to find an Item by its ID. Title The name of your Item. Categories An List of Item Categories. e.g. 'Food' or 'YourModName' Value The value of this item in OC. Description Description of your Object. Stackable The max stack size of this item. e.g. 64 ;D Appearance Material ??? SpritePath The path to place where the Item UI Image is stored. InGame Addressable or LavenderAsset. ColorValue ??? PrefabPath The path to place where the Item Prefab (InGame Object when dropped) is stored. InGame Addressable or LavenderAsset. PrefabPathMany Similar to PrefabPath, but this is the object shown, when you drop an stacked Item. Actions ??? Attachments ??? Meta ??? Appearance Warning Lavender supports loading images and obj's at runtime, but the obj importer is currently pretty buggy. For the best and more stable results use AssetBundle imports instead! Lavender allows you to use two ways to define the Item appearance: LavenderAssets: Use #lv_<YourModName>-<ID> e.g. #lv_SupperDuperMod-42 -> Learn more here Addressables: Because this Items.json is treated just like Obenseuer's Item.json you can also point to Obensuer's Game Assets: The Addressables"
  },
  "docs/Item-n-Recipe/ModifierInfo.html": {
    "href": "docs/Item-n-Recipe/ModifierInfo.html",
    "title": "ModifierInfo Class | Lavender Docs",
    "summary": "ModifierInfo Class Definition Namespace: Lavender.RecipeLib Source: ModifierInfo.cs Example // Loads an Icon.png by using Lavenders RuntimeImporter Sprite Icon = Lavender.RuntimeImporter.ImageLoader.LoadSprite(\"ModifierIcon.png\"); // Creates a new Modifier with the unique ID 101 ModifierInfo info = new RecipeLib.ModifierInfo(101, \"Modifier Example\", \"An Example Modifier\", Icon); Lavender.AddModifierInfo(info); // Applies the new Modifier to the 'Brick Furnace' crafting station Lavender.AddModifierToCraftingBase(\"Brick Furnace\", 101); Constructors ModifierInfo(int, string, string, Sprite) Creates a new crafting modifier Properties ID Unique Modifier ID TooltipTitle Modifier Title TooltipDetails Modifier Description Image Modifier Icon"
  },
  "docs/Item-n-Recipe/Recipes.html": {
    "href": "docs/Item-n-Recipe/Recipes.html",
    "title": "Recipes | Lavender Docs",
    "summary": "Recipes Note Item and Recipes are identified via integer values. This, unfortunately, means that conflicts between mods are possible if we (as a community) do not communicate and document which mod(ders) use which ID regions. See current ID Allocations here Recipes.json Example recipes.json from norbby42 (Quackers) Smuggler's Pack Mod [ { \"ID\": 400001, \"Name\": \"Smuggler's Pack Insert\", \"Type\": \"Sewing\", \"useOnlyStolenItems\": false, \"allowedNonStolenItemsIds\": [], \"keepItemOwnerOnFail\": false, \"disableJunkSpawn\": false, \"Appearance\": { \"SpritePath\": \"\", \"CraftShowModel\": true, \"itemToShow\": { \"ID\": 400001, \"name\": \"Smuggler's Pack Insert'\", \"itemnamespace\": null } }, \"RecipeRequired\": false, \"RequiredConditions\": [], \"ExcludingConditions\": [], \"RecipeTags\": [ \"Open Sewer Magazine\" ], \"variantItemCategory\": \"None\", \"variantItemAmount\": 0, \"input\": [ { \"Key\": { \"ID\": 14930, \"Title\": \"Empty Backpack\", \"itemnamespace\": null }, \"Value\": 1.0 }, { \"Key\": { \"name\": \"Cloth Roll\", \"itemnamespace\": null, \"ID\": 12700 }, \"Value\": 1.0 }, { \"Key\": { \"name\": \"Thread\", \"itemnamespace\": null, \"ID\": 15750 }, \"Value\": 4.0 }, { \"Key\": { \"name\": \"Scrap Metal\", \"itemnamespace\": null, \"ID\": 35180 }, \"Value\": 2.0 } ], \"output\": [ { \"Key\": { \"name\": \"Smuggler's Pack Insert\", \"itemnamespace\": null, \"ID\": 400001 }, \"Value\": 1.0 }, { \"Key\": { \"name\": \"Cloth Scraps\", \"itemnamespace\": null, \"ID\": 12680 }, \"Value\": 1.0 } ], \"outputFail\": [ { \"Key\": { \"name\": \"Cloth Scraps\", \"itemnamespace\": null, \"ID\": 12680 }, \"Value\": 2.0 }, { \"Key\": { \"name\": \"Scrap Metal\", \"itemnamespace\": null, \"ID\": 35180 }, \"Value\": 1.0 } ], \"metaSettings\": { \"setIntegrity\": 1.0, \"setIntegrityFail\": 0.5, \"useAmmoAsInput\": true, \"setAmmoOfMax\": 1.0, \"setAmmoOfMaxFail\": 0.0, \"useLiquidContainers\": false, \"returnLiquidContainers\": true, \"putLiquidsIntoContainer\": { \"name\": \"\", \"itemnamespace\": null, \"ID\": 0 }, \"qualityFactor\": 1.0, \"qualityFactorFail\": 0.5, \"useFixedQuality\": false, \"fixedQuality\": 1.0, \"mailName\": \"\", \"mailReceiver\": { \"name\": \"\", \"ID\": -1 } }, \"FailChance\": 0.85, \"RelevantSkill\": \"Sewing\", \"SkillFactor\": 1.0, \"ProcessTime\": 500, \"Meta\": null } ] In order to add Recipes through your own Recipes.json you need to register it to Lavender. string recipesPath = \"Recipes.json\"; Lavender.AddCustomRecipesFromJson(recipesPath, LCMPluginInfo.PLUGIN_NAME); Keys I won't explain any keys here for now, because I didn't work that much with Recipes yet. Please refer to Obenseurs Recipes.json. Appearance SpritePath The path to place where the Item UI Image is stored. InGame Addressable or LavenderAsset. Appearance Warning Lavender supports loading images and obj's at runtime, but the obj importer is currently pretty buggy. For the best and more stable results use AssetBundle imports instead! Lavender allows you to use two ways to define the Recipe appearance: LavenderAssets: Use #lv_<YourModName>-<ID> e.g. #lv_SupperDuperMod-42 -> Learn more here Addressables: Because this Recipes.json is treated just like Obenseuer's Recipes.json you can also point to Obensuer's Game Assets: The Addressables"
  },
  "docs/RuntimeImporter/FastObjImporter.html": {
    "href": "docs/RuntimeImporter/FastObjImporter.html",
    "title": "FastObjImporter Class | Lavender Docs",
    "summary": "FastObjImporter Class Definition Namespace: Lavender.RuntimeImporter Source: FastObjImporter.cs Import .obj files at runtime. Example Mesh mesh = FastObjImporter.Instance.ImportFile(\"McMushroom.obj\"); Static Properties Instance The current FastObjImporter instance. Methods ImportFile(string) Imports the given OBJ and returns an UnityEngine.Mesh Object."
  },
  "docs/RuntimeImporter/ImageLoader.html": {
    "href": "docs/RuntimeImporter/ImageLoader.html",
    "title": "ImageLoader Static Class | Lavender Docs",
    "summary": "ImageLoader Static Class Definition Namespace: Lavender.RuntimeImporter Source: ImageLoader.cs Import .png or .jpeg at runtime. Methods LoadImage(string) Imports an PNG/JPEG and returns a Texture2D object. LoadSprite(string) Imports an PNG/JPEG and returns a calibrated Sprite object."
  },
  "docs/RuntimeImporter/LavenderAsset.html": {
    "href": "docs/RuntimeImporter/LavenderAsset.html",
    "title": "LavenderAsset Class | Lavender Docs",
    "summary": "LavenderAsset Class Definition Namespace: Lavender.RuntimeImporter Source: LavenderAsset.cs Note LavenderAssets are also referenced as LVA Example LavenderAsset.json [ { \"ID\": 1, \"AssetType\": \"AssetBundle\", \"Data\": { \"path\": \"AssetBundleFile\", \"name\": \"AssetName\" } }, { \"ID\": 2, \"AssetType\": \"Image\", \"Data\": { \"path\": \"Image.png\", \"name\": \"\" } }, { \"ID\": 3, \"AssetType\": \"OBJ\", \"Data\": { \"path\": \"3DModel.obj\", \"name\": \"Example 3DModel\", \"objTexturePaths\": [ \"3DModel_Texture.png\" ] } } ] In order to use these LVAs in your FurnitureConfig.json or Item/Recipe.json you need to register them to Lavender: string path = \"YourLavenderAsset.json\"; Lavender.AddLavenderAssets(path, \"YourModName\"); // Now you can reference these LVAs as e.g. #lv_YourModName-1 When using GetAssetData<T>() for AssetBundle LVAs, T must be the Type of the Asset you want to load: LavenderAsset asset = Lavender.GetLavenderAsset(\"#lv_YourModName-1\"); // 'YourModName-1' would also work here! // GetAssetData<T>() returns a value of type 'object?'. // So if you want to use the return value as GameObject // you need to specify its type using '(GameObject)'. GameObject loadedPrefab = (GameObject)asset.GetAssetData<GameObject>(); Properties ID Unique ID AssetType Enum Data Methods GetAssetData() Loads the Asset specified in the Data Class AssetType Enum 1. AssetBundle path The file path to the AssetBundle file relative to this json file. name The name of your asset in the AssetBundle. 2. Image path The file path to the PNG or JPG file relative to this json file. 3. OBJ path The file path to the OBJ file relative to this json file. name The created mesh will be named 'name' + '_Mesh'. objTexturePaths The file path(s) to the OBJs Texture PNG or JPG file(s) relative to this json file. Each Texture will be interpreted by GetAssetData() as an extra Material."
  },
  "docs/StorageLib/StorageCategory.html": {
    "href": "docs/StorageLib/StorageCategory.html",
    "title": "StorageCategory | Lavender Docs",
    "summary": "StorageCategory StoragePrefab.json The StorageCategory defines the size, refrigeration and sounds of an storage. Example [ { \"id\": 1, \"Name\": \"Chest\", \"Panels\": 24, \"Refigerated\": 0.0, \"OpenSoundPath\": \"Sounds/object/chest_001_open\", \"OpenSoundVolume\": 1, \"OpenSoundPitch\": 1, \"OpenSoundDistance\": 20, \"CloseSoundPath\": \"Sounds/object/chest_001_close\", \"CloseSoundVolume\": 1, \"CloseSoundPitch\": 1, \"CloseSoundDistance\": 20, \"LockedSoundPath\": \"Sounds/object/chest_001_locked\", \"LockedSoundVolume\": 1, \"LockedSoundPitch\": 1, \"LockedSoundDistance\": 20, \"UnlockSoundPath\": \"Sounds/door/door_unlock_keys_001\", \"UnlockSoundVolume\": 1, \"UnlockSoundPitch\": 1, \"UnlockSoundDistance\": 20, \"LockpickSoundPath\": \"Sounds/door/door_unlock_001\", \"LockpickSoundVolume\": 1, \"LockpickSoundPitch\": 1, \"LockpickSoundDistance\": 20 }, ] Keys The Name key is used to identify a StorageCategory in the Database. The Panels key determines the storage size. (max value 88) The Refigerated key determines the refrigeration factor. (Refrigerator 0 - 1. Freezer 1 or more)"
  },
  "docs/StorageLib/StorageCreator.html": {
    "href": "docs/StorageLib/StorageCreator.html",
    "title": "StorageCreator Static Class | Lavender Docs",
    "summary": "StorageCreator Static Class Definition Namespace: Lavender.StorageLib Source: Type.cs Example [FurniturePrefabHandler(\"Shipping Container\")] public static GameObject ShippingContainerHandler(GameObject gameObject) { StorageCreator.AddSimpleStorage(gameObject, \"Shipping Container\", \"Enter\", \"ShippingContainer\"); return gameObject; } Methods AddSimpleStorage(GameObject, string, string, string) Setups a Storage component without any spawn information."
  },
  "docs/StorageLib/StorageSpawnCategory.html": {
    "href": "docs/StorageLib/StorageSpawnCategory.html",
    "title": "StorageCategory | Lavender Docs",
    "summary": "StorageCategory StorageSpawnCategory.json To do Example { \"$content\": [ { \"ID\": 10001, \"Name\": \"Fridge\", \"ItemCommon\": [ 6, 8, 22030, 22050, 24070, 24060, 24010, 7, 20010, 20020, 180110, 20210, 2, 13350, 14080, 14850, 16790 ], \"ItemRare\": [ 14, 24050, 26010, 26070, 26060, 26510, 20110, 20030, 20040, 20050, 180060, 14090, 14570, 16820 ], \"MetaValues\": { \"perishable\": { \"integrityMin\": 0.5, \"integrityMax\": 1.0 }, \"ammo\": { \"ammoMin\": 0.0, \"ammoMax\": 1.0 }, \"liquid\": { \"liquidItems\": [ { \"name\": \"Cooking oil\", \"itemnamespace\": null, \"ID\": 150040 }, { \"name\": \"Water\", \"itemnamespace\": null, \"ID\": 10840 }, { \"name\": \"Pure Water\", \"itemnamespace\": null, \"ID\": 15970 }, { \"name\": \"Blackcurrant Juice\", \"itemnamespace\": null, \"ID\": 16250 }, { \"name\": \"Blackcurrant Juice Concentrate\", \"itemnamespace\": null, \"ID\": 16240 }, { \"name\": \"Spring Water\", \"itemnamespace\": null, \"ID\": 16200 } ], \"liquidAmountMin\": 0.0, \"liquidAmountMax\": 1.0, \"useLiquidsInOrder\": false, \"liquidsInOrderAmount\": [], \"allowedContainers\": { } }, \"quality\": { \"qualityMin\": 0.1, \"qualityMax\": 2.0 } } }, ] }"
  },
  "docs/lavender.html": {
    "href": "docs/lavender.html",
    "title": "Lavender Class | Lavender Docs",
    "summary": "Lavender Class Definition Namespace: Lavender Source: Lavender.cs Lavenders \"Main\" Class, you will use it pretty often. Properties isInitialized harmony lastLoadedScene The build index of the last scene during the \"SceneManager.sceneLoaded\" callback LoadingDone You want to execute your mod logic only when LoadingDone = true to make sure that all game logic is already initialized! Static Properties instance Provides the current Lavender instance FurnitureDatabase A list of all modded furniture's using Lavender. customItemDatabase A list of all modded items using Lavender. customRecipeDatabase A list of all modded Recipes using Lavender. customStorageCategoryDatabase A list of all modded StorageCategories using Lavender. customStorageSpawnCategoryDatabase A list of all modded StorageSpawnCategories using Lavender. Static Methods AddLavenderAssets(string, string) GetLavenderAsset(string) Tries to find the LavenderAsset by its ID 'modname-id' or '#lv_modname-id' GetLavenderAssetsFromMod(string) Returns all LavenderAssets added using the given mod name. FetchFurnitureByTitle(string) FetchFurnitureByID(string) AddFurniturePrefabHandlers(Type) Gets all FurniturePrefabHandler methods defined in the given Type: type and registers them for the Handler callback AddFurnitureShopRestockHandlers(Type) Gets all FurnitureShopRestockHandler methods defined in the given Type: type and registers them for the Handler callback AddCustomItem(Item, string) AddCustomItemsFromJson(string, string) AddCustomRecipe(Recipe, string) AddCustomRecipesFromJson(string, string) AddModifierToCraftingBase(string, int, bool = false) Adds a Modifier using its ID to a crafting station AddModifierInfo(ModifierInfo) AddCustomStorageCategory(StorageCategory) AddCustomStorageCategoryFromJson(string, string) AddCustomStorageSpawnCategory(StorageSpawnCategory) AddCustomStorageSpawnCategoryFromJson(string, string)"
  },
  "index.html": {
    "href": "index.html",
    "title": "| Lavender Docs",
    "summary": "Lavender is a powerful and user-friendly library mod designed to simplify the process of modding the game Obenseuer using BepInEx as mod loader. Contributing Contributions are welcome! Whether you're fixing bugs, adding new features, or improving documentation, your help is appreciated. To contribute, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change. Here are some basic resources on code style and naming conventions Lavender try's to fulfill: Coding Conventions Identifier Names Repositories: Lavender - The library code! Lavender Docs - Documentation Repo & this GitHub Page License This project is licensed under the LGPL-v2.1 license"
  },
  "template/class.html": {
    "href": "template/class.html",
    "title": "TYPE Class | Lavender Docs",
    "summary": "TYPE Class Definition Namespace: Source: Type.cs Remarks Constructors func(object, string) Description Properties Property Description Static Properties Property Description Methods func(object, string) Description"
  }
}